#!/bin/sh /etc/rc.common
# Copyright (C) 2006 OpenWrt.org

START=99
NAME=lanaggregation
EXTRA_COMMANDS="reset"


BOND_IFNAME="bond0"
LAN_IFNAME="br-lan"
LAN_IFNAMES="eth0.2 eth1.3 eth1.4 eth0.1"
wan_ifname="eth1.5"
lag_enable=$(uci -q get lag.lag.enable)
wan_type=$(uci -q get xiaoqiang.common.wan_port_type)
ap_mode=$(uci -q get xiaoqiang.common.NETMODE)
dualwan_enable=$(uci -q get dualwan.common.enable)

log(){
	echo "[LAG] $@" > /dev/console
}

set_lag_network() {
	if [ "$lag_enable" == "0" ]; then
		LAN_IFNAMES="eth1.2 eth1.3 eth1.4 eth0.1"
	fi
	if [ "$wan_type" = "1G" ]; then
		LAN_IFNAMES="eth0.2 eth1.3 eth0.1 eth1.5"
		[ "$lag_enable" == "0" ] && LAN_IFNAMES="eth1.2 eth1.3 eth1.5 eth0.1"
		[ "$dualwan_enable" == "1" ] && LAN_IFNAMES="eth1.2 eth1.3 eth0.1"
	else
		if [ "$dualwan_enable" = "1" ]; then
			LAN_IFNAMES="eth1.2 eth1.3 eth0.1"
		fi
	fi

	if [ "$ap_mode" = "wifiapmode" -o "$ap_mode" = "lanapmode" -o "$ap_mode" = "whc_re" ]; then
		LAN_IFNAMES="eth0.2 eth1.3 eth1.4 eth0.1 eth1.5"
		[ "$lag_enable" == "0" ] && LAN_IFNAMES="eth1.2 eth1.3 eth1.4 eth0.1 eth1.5"
	fi
	wan_ifname=$(uci -q get network.wan.ifname)
}

lag_network_restart() {
    /etc/init.d/network stop
    for count in 0 1 2 3 4 5 6 7 8 9;
    do
		sleep 1
		ps ww | grep "network.interface" | grep -v grep
		if [ "$?" = "1"  ]; then
			break
		fi
    done
    /etc/init.d/network start
}

open_lag_network() {
	uci -q batch <<EOF
	set network.lan.ifname='$LAN_IFNAMES'
	commit network
EOF
}

close_lag_network() {
	uci -q batch <<EOF
	set network.lan.ifname='$LAN_IFNAMES'
	commit network
EOF
}

get_ifname_from_portid(){
	local portid=$1
	local index=1

	for ifname in $LAN_IFNAMES;
	do
		if [ $index == $portid ]; then
			echo "$ifname"
			return 1
		fi

		index=`expr $index + 1`
	done

	echo ""
}

get_lag_ifnames(){
	local lag_ports=$(uci -q get lag.lag.ports)
	local lagIfnames=""

	for p in $lag_ports;
	do
		ifname=$(get_ifname_from_portid "$p")
		[ -n "$ifname" ] && {
			[ -z "lagIfnames" ] && lagIfnames=$ifname
			lagIfnames=${lagIfnames}" $ifname"
		}
	done

	echo "$lagIfnames"
}

is_slave_ifname(){
	local ifname="$1"
	local slave_list=$(get_lag_ifnames)

	for slave in $slave_list;
	do
		[ "$slave" = "$ifname" ] && {
			echo 0
			return
		}
	done

	echo 1
}

get_lan_ifnames(){
	local enable=$(uci -q get lag.lag.enable)
	local lan_ifnames=""

	if [ "$enable" = "1" ]; then
		for ifname in $LAN_IFNAMES;
		do
			[ 1 -eq $(is_slave_ifname "$ifname") ] && {
				[ -z "lan_ifnames" ] && lan_ifnames=$ifname
				lan_ifnames=${lan_ifnames}" $ifname"
			}
		done
	else
		lan_ifnames=$LAN_IFNAMES
	fi

	echo "$lan_ifnames"
}

set_driver_values() {
	local bondif="$1"
	local varname="$2"
	local value="$3"

	[ -n "$value" ] && echo "$value" > /sys/class/net/"$bondif"/bonding/"$varname"
}

diable_lan_aggregation() {
	local boot=$1
	local lan_ifnames=$LAN_IFNAMES

	log "Disable LAG">/dev/console

	if [ "$(cat /proc/net/dev |grep "$BOND_IFNAME")" == "" ]; then
		log "ERROR - $BOND_IFNAME: No such device"
		return
	fi

	echo "-$BOND_IFNAME" > /sys/class/net/bonding_masters

	uci -q batch <<EOF
	delete network.bond0
	set network.lan.ifname='$lan_ifnames'
	commit network
EOF

	case "$boot" in
	"run"|"reset")
		ubus call network reload
		;;
	esac
}

enable_lan_aggregation(){
	local boot=$1
	local mode=$(uci -q get lag.lag.mode)
	local slave_list=$(get_lag_ifnames)
	local lan_ifnames=$(get_lan_ifnames)
	local xmit_hash_policy=""
	local all_slaves_active=""
	local ad_select=""
	local ad_actor_sys_prio=1
	local miimon=100
	local lacp_rate=1
	local ifname="$BOND_IFNAME"

	[ -z "$slave_list" ] && {
		log "ERROR - no slave exist!"
		return
	}

	# 0 is XOR Mode
	# 1 is 8023AD LCAP Passive Mode
	# 2 is 8023AD LCAP Active Mode
	case "$mode" in
		"0")
			mode="balance-xor"
			xmit_hash_policy=0
		;;

		"1")
			mode="802.3ad"
			all_slaves_active=0
			xmit_hash_policy=0
			ad_select=0
		;;

		"2")
			mode="802.3ad"
			all_slaves_active=1
			xmit_hash_policy=1
			ad_select=2
		;;

		*)
			log "ERROR - $mode: Unsupported lag mode"
			return
		;;
	esac

	log "Enabling LAG">/dev/console
	log "slave_list : $slave_list">/dev/console
	log "lan_ifnames : $lan_ifnames">/dev/console
	log "mode : $mode">/dev/console


	# Check for loaded kernel bonding driver
	[ -f "/sys/class/net/bonding_masters" ] || {
		log "ERROR - bonding_masters does not exist"
		return
	}

	# Add bonding interface to system
	echo "+$BOND_IFNAME" > /sys/class/net/bonding_masters

	# set mode
	set_driver_values $BOND_IFNAME "mode" $mode

	for slave in $slave_list; do
		log "mi_bond add slave : $slave">/dev/console
		if [ "$(cat /proc/net/dev |grep "$slave")" == "" ]; then
			log "ERROR - $slave: No such device"
			return
		fi

		log "mi_bond del bridge slave : $slave">/dev/console
		brctl delif $LAN_IFNAME $slave
		ifconfig "$slave" down

		sleep 1

		set_driver_values $BOND_IFNAME "slaves" "+$slave"

		#ifconfig "$slave" up
	done

	[ -n "$xmit_hash_policy" ] && set_driver_values $BOND_IFNAME "xmit_hash_policy" "$xmit_hash_policy"
	[ -n "$ad_select" ] && set_driver_values $BOND_IFNAME "ad_select" "$ad_select"
	[ -n "$all_slaves_active" ] && set_driver_values $BOND_IFNAME "all_slaves_active" "$all_slaves_active"
	[ -n "$ad_actor_sys_prio" ] && set_driver_values $BOND_IFNAME "ad_actor_sys_prio" "$ad_actor_sys_prio"
	[ -n "$miimon" ] && set_driver_values $BOND_IFNAME "miimon" "$miimon"
	[ -n "$lacp_rate" ] && set_driver_values $BOND_IFNAME "lacp_rate" "$lacp_rate"

	uci -q batch <<EOF
	delete network.bond0
	set network.lan.ifname='$lan_ifnames $BOND_IFNAME'
	set network.bond0=interface
	set network.bond0.ifname='bond0'
	set network.bond0.keepup='1'
	commit network
EOF

	case "$boot" in
	"run"|"reset")
		#ifconfig $wan_ifname down
		#ubus call network restart
		ifconfig $BOND_IFNAME up   
		brctl addif $LAN_IFNAME $BOND_IFNAME
		;;

	esac
}

start() {
    log "START lan aggregation">/dev/console
    [ "$lag_enable" == "0" ] && return 0
    set_lag_network
    open_lag_network
    lag_network_restart
    sleep 3
    enable_lan_aggregation "run"
    return 0
}

stop() {
    log "STOP lan aggregation">/dev/console
    set_lag_network
    close_lag_network
    lag_network_restart
    diable_lan_aggregation "run"
}

reset() {
    [ "$lag_enable" == "0" ] && return 0
    set_lag_network
    sleep 2
    diable_lan_aggregation "reset"
    sleep 2
    enable_lan_aggregation "reset"
}

boot() {
    log "BOOT START lan aggregation">/dev/console
    if [ "$lag_enable" == "0" -a "$(cat /proc/net/dev |grep "$BOND_IFNAME")" != "" ]; then
		echo "-$BOND_IFNAME" > /sys/class/net/bonding_masters
    fi
    reset
    return 0
}
