#!/usr/bin/env lua
--[[
 * A lua library to translate from /etc/config/wireless into
 * MediaTek's WiFi profile (mt76xx.dat) and vice-versa.
 *
 * Copyright (C) 2018 Hua Shao <nossiac@163.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
]]

package.path = '../?.lua;'..package.path

local uci = require("shuci")
local l1profile = "/etc/wireless/l1profile.dat"
local ucifile = "/etc/config/wireless"

-- this flag is used in uci2dat and dat2uci
-- if set to true, the tool will NOT actually modify the target file,
-- but dump the result to stdout
local testmode = false

-- this flag is used in datdiff
-- if false, will dump diff result in plain text
-- if true, will generate "iwpriv" commands according to diff result
local iwpriv_mode = false

function __trim(s)
  if s then return (s:gsub("^%s*(.-)%s*$", "%1")) end
end

-- lua sorted pairs
function __spairs(t, order)
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end
    table.sort(keys, order)

    -- return a closure as an iterator
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

function string:split(sep)
    local sep, fields = sep or ":", {}
    local pattern = string.format("([^%s]+)", sep)
    self:gsub(pattern, function(c) fields[#fields+1] = c end)
    return fields
end

-- load MediaTek WiFi profile as a lua table
function load_profile(path)
    local cfgs = {}
    local fd = io.open(path, "r")
    if not fd then return cfgs end

    for line in fd:lines() do
        line = __trim(line)
        if string.byte(line) ~= string.byte("#") then
            local i = string.find(line, "=")
            if i then
                local k,v
                k = string.sub(line, 1, i-1)
                v = string.sub(line, i+1)
                -- if cfgs[__trim(k)] then
                --     print("warning", "skip repeated key"..line)
                -- end
                cfgs[__trim(k)] = __trim(v) or ""
            -- else
            --     print("warning", "skip line without '=' "..line)
            end
        -- else
        --     print("warning", "skip comment line "..line)
        end
    end
    fd:close()
    return cfgs
end


-- save configuration table as MediaTek wifi profile
function save_profile(cfgs, path)
    local fd = io.stdout
    if path then fd = io.open(path, "w") end

    fd:write("# Generated by uci2dat\n")
    fd:write("Default\n")
    for k,v in __spairs(cfgs) do
        fd:write(k.."="..v.."\n")
    end
    fd:close()
end


function merge_profile(t1, t2)
    if not t1 or not t2 or not next(t2) then return end
    for k,v in pairs(t2) do
        t1[k] = v
    end
end

function vifs_cfg_param(param)
    local vifs_cfg_params = {"Auth", "EncrypType", "Key", "WPAPSK", ";", "HT_BW", "VHT_BW", "HT_BSSCoexistence"}
    for _, pat in ipairs(vifs_cfg_params) do
        if string.find(param, pat) then
            return true
        end
    end
    return false
end

-- dev cfg need set ssid
-- key = dat parm, value is for iwpriv cmd.
-- for example : when key = HT_MCS, then iwpriv set ra0 HtMcs=xxx
function match_dev_parm(key)
    local dat_iw_table = {
                    CountryCode = "CountryCode",
                    CountryRegion = "CountryRegion",
                    CountryRegionABand = "CountryRegionABand",
                    BGProtection = "BGProtection",
                    ShortSlot = "ShortSlot",
                    PktAggregate = "PktAggregate",
                    HT_BADecline = "BADecline",
                    HT_DisallowTKIP = "HtDisallowTKIP",
                    TxPreamble = "TxPreamble",
                    DtimPeriod = "DtimPeriod",
                    TxBurst =  "TxBurst",
                    HT_MCS = "HtMcs",
                    HT_EXTCHA = "HtExtCha",
                    HT_MpduDensity = "HtMpduDensity",
                    HT_RDG = "HtRdg",
                    VOW_Airtime_Fairness_En = "vow_airtime_fairness_en",
                    HT_TxStream = "HtTxStream",
                    HT_RxStream = "HtRxStream",
                    IEEE80211H = "IEEE80211H",
                    HT_BAWinSize = "HtBaWinSize"
    }

    return dat_iw_table[key]
end

-- dev cfg no need set ssid
function match_dev_parm_no_ssid(key)
    local dat_iw_table = {
                    BeaconPeriod = "BeaconPeriod",
                    PartialScan = "PartialScan",
                    AntCtrl = "AntCtrl",
    }

    return dat_iw_table[key]
end

-- vif cfg need set ssid
function match_vif_parm(key)
    local dat_iw_table = {
                    APSDCapable = "UAPSDCapable",
                    UAPSDCapable = "UAPSDCapable",
                    FragThreshold = "FragThreshold",
                    HT_AMSDU = "HtAmsdu",
                    HT_AutoBA = "HtAutoBa",
                    HT_GI = "HtGi",
                    HT_OpMode = "HtOpMode",
                    HT_PROTECT = "HtProcect",
                    HT_STBC = "HtStbc",
                    IgmpSnEnable = "IgmpSnEnable",
                    NoForwarding = "NoForwarding",
                    HideSSID = "HideSSID",
                    WmmCapable = "WmmCapable",
                    PMKCachePeriod = "PMKCachePeriod",
                    PreAuth = "PreAuth",
                    PMFMFPC = "PMFMFPC",
                    PMFMFPR = "PMFMFPR",
                    PMFSHA256 = "PMFSHA256",
                    VHT_STBC = "VhtStbc",
                    WirelessMode = "WirelessMode",
                    WscConfMode = "WscConfMode",
                    WscConfStatus = "WscConfStatus",
                    VHT_BW_SIGNAL = "VhtBwSignal",
     }

    return dat_iw_table[key]
end

-- vif cfg no need set ssid
function match_vif_parm_no_ssid(key)
    local dat_iw_table = {
                    RTSThreshold = "RTSThreshold",
                    MgmtTxPwr = "mgmt_frame_pwr",
                    MbssMaxStaNum = "MbssMaxStaNum",
                    MaxStaNum = "MaxStaNum",
                    Restart ="Restart",
    }

    return dat_iw_table[key]
end

-- cfgs,   config data parsed from wifi old profile
-- diff,   difference between old profile and new profile
-- device, device data parsed from l1profile
function __set_wifi_misc(cfgs, diff, device)
    local mainifname = device.main_ifname
    local vifname = device.main_ifname
    local vifidx = cfgs.vifidx:split(";")
    local vifext = device.ext_ifname
    local last_command = string.format([[
                iwpriv %s set SSID="%s";]], vifname, cfgs.SSID1)

    local function read_file(path)
        local f = assert(io.open(path,'r'))
        local content = f:read('*all')
        f:close()
        return  __trim(content)
    end

    -- The main_if may be down, so we use the vif which stat is up as device vifname.
    for i=1, #vifidx do
        stat = read_file("/sys/class/net/"..vifext..tostring(tonumber(i)-1).."/operstate")
        if stat ~= "down"  then
            vifname = vifext..tostring(tonumber(i)-1)
            last_command = string.format([[
                iwpriv %s set SSID="%s";]], vifname, cfgs["SSID"..tostring(i)])
            break
        end
    end

    local commands_vifs_ssid = false
    local commands_dev = false -- device level config exist, need last_command
    local commands_ssid = {}
    local commands_access_1 = {} -- for black list
    local commands_access_2 = {}
    local commands_bw = false -- for BW, to prevent exexute cmd twice

    local token = function(str, n, default)
        local i = 1
        local list = {}
        for k in string.gmatch(str, "([^;]+)") do
            list[i] = k
            i = i + 1
        end
        return list[tonumber(n)] or default
    end

    for k,v in pairs(diff) do
        local commands, cmdacs, commandns
        local commands_1, commands_2 --for multi-cmd
        local commands_vifs

        if k:find("^SSID") then
            local _,_,i = string.find(k, "^SSID([%d]+)")
            if i == "1" then
                last_command = string.format([[
                iwpriv %s set SSID="%s";]], mainifname, tostring(v[2]))
                commands_dev = true
            else
                commands_ssid[i] = string.format([[
                iwpriv %s set SSID="%s";]], vifext..tostring(tonumber(i)-1), tostring(v[2]))
            end
        ----------------------------------------------------------------------------------------------------
                    -----------------------------device config ----------------------------
        -- Device level cfg, need set ssid to make it work.
        elseif k == "Channel" or k == "channel" then
            if v[2] == "0" then
                cmdacs = string.format([[
                iwpriv %s set AutoChannelSel=3;]], vifname)
            else
            commands = string.format([[
                iwpriv %s set Channel=%s;]], vifname, tostring(v[2]))
            end
            if cmdacs then print(cmdacs) end
        elseif k == "AutoChannelSelect" then
            -- do nothing

        -- Find k in dat_iw_table and return the iwkey for iwpriv.
        elseif match_dev_parm(k) then
            commands = string.format([[
                iwpriv %s set %s=%s;]], vifname, tostring(match_dev_parm(k)), tostring(v[2]))

        -- Device level cfg, don't need set SSID
        elseif match_dev_parm_no_ssid(k) then
            commandns = string.format([[
                iwpriv %s set %s=%s;]], vifname, tostring(match_dev_parm_no_ssid(k)), tostring(v[2]))

        elseif k == "TxPower" or  k == "txpower" then
            commands_1 = string.format([[
                iwpriv %s set TxPower=%s;]], vifname, tostring(v[2]))
            if commands_1 then print(commands_1) end
            commands_1 = string.format([[
                iwpriv %s set PercentageCtrl=1;]], vifname)
            commands_2 = string.format([[
                iwpriv %s set PowerDropCtrl=%s;]], vifname, tostring(v[2]))
            if commands_2 then print(commands_1) print(commands_2) end
        elseif k == "APAifsn" or k == "apaifsn" then
            local v_aifsn = string.gsub(tostring(v[2]), ";", ":")
            commands_1 = string.format([[
                iwpriv %s set APAifsn=%s;]], vifname, v_aifsn)
            if commands_1 then print(commands_1) end
        elseif k == "APCwmax" or k == "apcwmax" then
            local v_cwmax = string.gsub(tostring(v[2]), ";", ":")
            commands_1 = string.format([[
                iwpriv %s set APCwmax=%s;]], vifname, v_cwmax)
            if commands_1 then print(commands_1) end
        elseif k == "APCwmin" or k == "apcwmin" then
            local v_cwmin = string.gsub(tostring(v[2]), ";", ":")
            commands_1 = string.format([[
                iwpriv %s set APCwmin=%s;]], vifname, v_cwmin)
            if commands_1 then print(commands_1) end
        elseif k == "APTxop" or k == "aptxop" then
            local v_txop = string.gsub(tostring(v[2]), ";", ":")
            commands_1 = string.format([[
                iwpriv %s set APTxop=%s;]], vifname, v_txop)
            if commands_1 then print(commands_1) end

        ----------------------------------------------------------------------------------------------------
                    -----------------------------interface config ----------------------------
         -- Common case, set vif parameter and it's ssid
        elseif match_vif_parm(k) then
            for i=1, #vifidx  do
              if token(cfgs[k], i) ~= token(diff[k][2], i) then
                commands_vifs = string.format([[
                iwpriv %s set %s=%s;]], vifext..tostring(tonumber(i)-1), tostring(match_vif_parm(k)), token(diff[k][2], i))
                commands_ssid[i] = string.format([[
                iwpriv %s set SSID=%s;]], vifext..tostring(tonumber(i)-1), diff["SSID"..tostring(i)] and 
                        tostring(diff["SSID"..tostring(i)][2]) or cfgs["SSID"..tostring(i)])
                print(commands_vifs)
              end
            end

        -- Don't need to set SSID, it will take effect immediately after iwpriv
        elseif match_vif_parm_no_ssid(k) then
            for i=1, #vifidx  do
              if token(cfgs[k], i) ~= token(diff[k][2], i) then
                commands_vifs = string.format([[
                iwpriv %s set %s=%s;]], vifext..tostring(tonumber(i)-1), tostring(match_vif_parm_no_ssid(k)), token(diff[k][2], i))
                print(commands_vifs)
              end
            end

        -- Special case : need to set multiple parameters at the same time when one parameter changed
        elseif not commands_bw and k == "HT_BSSCoexistence" then
            for i=1, #vifidx  do
                commands_vifs = string.format([[
                iwpriv %s set HtBssCoex=%s;]], vifext..tostring(tonumber(i)-1), tostring(v[2]))
                commands_1 = string.format([[
                iwpriv %s set HtBw=%s;]], vifext..tostring(tonumber(i)-1), diff["HT_BW"] and tostring(diff["HT_BW"][2])
                    or tostring(cfgs["HT_BW"]))
                commands_2 = string.format([[
                iwpriv %s set VhtBw=%s;]], vifext..tostring(tonumber(i)-1), diff["VHT_BW"] and tostring(diff["VHT_BW"][2])
                    or tostring(cfgs["VHT_BW"]))
                if commands_vifs then
                    print(commands_vifs)
                    print(commands_1)
                    print(commands_2)
                end
            end
            commands_vifs_ssid = true
            commands_bw = true
        elseif not commands_bw and k == "HT_BW" then
            local htbw = v[2]
            local vhtbw = diff["VHT_BW"] and tostring(diff["VHT_BW"][2]) or tostring(cfgs["VHT_BW"])
            for i=1, #vifidx  do
                commands_vifs = string.format([[
                iwpriv %s set HtBw=%s;]], vifext..tostring(tonumber(i)-1), tostring(v[2]))
                commands_1 = string.format([[
                iwpriv %s set VhtBw=%s;]], vifext..tostring(tonumber(i)-1), tostring(vhtbw))
                -- workaround
                if htbw == "1" and vhtbw == "0" then
                    commands_2 = string.format([[
                iwpriv %s set HtBssCoex=%s;]], vifext..tostring(tonumber(i)-1), diff["HT_BSSCoexistence"]
                                and tostring(diff["HT_BSSCoexistence"][2]) or tostring(cfgs["HT_BSSCoexistence"]))
                else
                    commands_2 = string.format([[
                iwpriv %s set HtBssCoex=0;]], vifext..tostring(tonumber(i)-1))
                end
                if commands_vifs then
                    print(commands_vifs)
                    print(commands_1)
                    print(commands_2)
                end
            end
            commands_vifs_ssid = true
            commands_bw = true
        elseif not commands_bw and k == "VHT_BW" then
            local vhtbw = v[2]
            local htbw = diff["HT_BW"] and tostring(diff["HT_BW"][2]) or tostring(cfgs["HT_BW"])
            for i=1, #vifidx  do
                commands_vifs = string.format([[
                iwpriv %s set VhtBw=%s;]], vifext..tostring(tonumber(i)-1), tostring(v[2]))
                commands_1 = string.format([[
                iwpriv %s set HtBw=%s;]], vifext..tostring(tonumber(i)-1), tostring(htbw)
                    or tostring(cfgs["HT_BW"]))
                 -- workaround
                if htbw == "1" and vhtbw == "0" then
                    commands_2 = string.format([[
                iwpriv %s set HtBssCoex=%s;]], vifext..tostring(tonumber(i)-1), diff["HT_BSSCoexistence"]
                                and tostring(diff["HT_BSSCoexistence"][2]) or tostring(cfgs["HT_BSSCoexistence"]))
                else
                    commands_2 = string.format([[
                iwpriv %s set HtBssCoex=0;]], vifext..tostring(tonumber(i)-1))
            end
                if commands_vifs then
                    print(commands_vifs)
                    print(commands_1)
                    print(commands_2)
            end
            end
            commands_vifs_ssid = true
            commands_bw = true
        elseif k == "BSSAifsn" or k == "bssaifsn" then
            local v_aifsn = string.gsub(tostring(v[2]), ";", ":")
            for i=1, #vifidx  do
                commands_1 = string.format([[
                iwpriv %s set BSSAifsn=%s;]], vifext..tostring(tonumber(i)-1), v_aifsn)
                if commands_1 then print(commands_1) end
            end
        elseif k == "BSSCwmax" or k == "bsscwmax" then
            local v_cwmax = string.gsub(tostring(v[2]), ";", ":")
            for i=1, #vifidx  do
                commands_1 = string.format([[
                iwpriv %s set BSSCwmax=%s;]], vifext..tostring(tonumber(i)-1), v_cwmax)
                if commands_1 then print(commands_1) end
            end
        elseif k == "BSSCwmin" or k == "bsscwmin" then
            local v_cwmin = string.gsub(tostring(v[2]), ";", ":")
            for i=1, #vifidx  do
                commands_1 = string.format([[
                iwpriv %s set BSSCwmin=%s;]], vifext..tostring(tonumber(i)-1), v_cwmin)
                if commands_1 then print(commands_1) end
            end
        elseif k == "BSSTxop" or k == "bsstxop" then
            local v_txop = string.gsub(tostring(v[2]), ";", ":")
           for i=1, #vifidx  do
                commands_1 = string.format([[
                iwpriv %s set BSSTxop=%s;]], vifext..tostring(tonumber(i)-1), v_txop)
                if commands_1 then print(commands_1) end
            end
        elseif k:find("AccessPolicy") then
            local index = string.match(k, '%d')
            if commands_access_2[index] then return end
            commands_1 = string.format([[
                    iwpriv %s set AccessPolicy=%s;]], vifext..tostring(index), tostring(v[2]))
            print(commands_1)
            if v[2] == '0' then break end

            -- Delete all entry first
            local commands_del_list = string.format([[
                    iwpriv %s set ACLClearAll=1;]], vifext..tostring(index))
            print(commands_del_list)
            local list_old = cfgs["AccessControlList"..tostring(index)]:split(" ") or {}
            local list_new = diff["AccessControlList"..tostring(index)] and diff["AccessControlList"..tostring(index)][2]:split(" ") or {}
            local list_old_i = (list_old[1] or ''):split(";")
            local list_new_i = (list_new[1] or ''):split(";")

            if diff["AccessControlList"..tostring(index)] then
                for i=1, #list_new_i do
                    local commands_aclist = string.format([[
                    iwpriv %s set ACLAddEntry=%s;]], vifext..tostring(index), list_new_i[i])
                    print(commands_aclist)
                end
            elseif cfgs["AccessControlList"..tostring(index)] and cfgs["AccessControlList"..tostring(index)] ~= "" then
                for i=1, #list_old_i do
                    local commands_aclist = string.format([[
                    iwpriv %s set ACLAddEntry=%s;]], vifext..tostring(index), list_old_i[i])
                    print(commands_aclist)
                end
            end
            commands_access_1[index] = true
        elseif k:find("AccessControlList") then
            local index = string.match(k, '%d')
            if commands_access_1[index] then return end

            -- Clear all entry first
            local commands_del_list = string.format([[
                    iwpriv %s set ACLClearAll=1;]], vifext..tostring(index))
            print(commands_del_list)
            -- Then add entries
            local commands_ac = string.format([[
                    iwpriv %s set AccessPolicy=%s;]], vifext..tostring(index),  diff["AccessPolicy"..tostring(index)]
                and tostring(diff["AccessPolicy"..tostring(index)][2]) or cfgs["AccessPolicy"..tostring(index)])
            print(commands_ac)
            local list_new = diff["AccessControlList"..tostring(index)] and diff["AccessControlList"..tostring(index)][2]:split(" ") or {}
            local list_new_i = (list_new[1] or ''):split(";")

            if diff["AccessControlList"..tostring(index)] and #list_new_i > 0 then
                for i=1, #list_new_i do
                    local commands_aclist = string.format([[
                    iwpriv %s set ACLAddEntry=%s;]], vifext..tostring(index), list_new_i[i])
                    print(commands_aclist)
             end
            end
            commands_access_2[index] = true
        elseif not vifs_cfg_param(k) and not vifs_cfg_param(v[2]) then
            for i=1, #vifidx  do
                commands_vifs = string.format([[
                iwpriv %s set %s=%s;]], vifext..tostring(tonumber(i)-1), k, tostring(v[2]))
                if commands_vifs then print(commands_vifs) end
            end
            commands_vifs_ssid = true
        end

        if commands then
            print(commands)
            commands_dev = true
        elseif commandns then
            print(commandns)
        end
    end

    if commands_vifs_ssid then
        for i=1, #vifidx  do
            commands_vifs_ssid = string.format([[
                iwpriv %s set SSID="%s";]], vifext..tostring(tonumber(i)-1),
                diff["SSID"..tostring(i)] and tostring(diff["SSID"..tostring(i)][2]) or cfgs["SSID"..tostring(i)])
            print(commands_vifs_ssid)
        end
    else
        local ssid1 = true
        for i=1, #vifidx  do
            if commands_ssid[i] then
                print(commands_ssid[i])
                if i == 1 then ssid1 = false end
            end
        end
        if ssid1 and commands_dev then print(last_command) end
    end
end

function __set_wifi_security(cfgs, diff, device)
    -- to keep it simple, we always reconf the security if anything related is changed.
    -- do optimization only if there's significant performance defect.

    local vifs = {} -- changed vifs

    -- figure out which vif is changed
    -- since multi-bssid is possible, both AuthMode and EncrypType can be a group
    local auth_old = cfgs.AuthMode:split()
    local encr_old = cfgs.EncrypType:split()
    local auth_new = {}
    local auth_new1 = {}
    local encr_new = {}
    local encr_new1 = {}
    if diff.EncrypType then
        encr_new = diff.EncrypType[2]:split()
        encr_new1 = encr_new[1]:split(";")
    end
    if diff.AuthMode then
        auth_new = diff.AuthMode[2]:split()
        auth_new1 = auth_new[1]:split(";")
    end

    -- For WPA/WPA2
    local RadiusS_old = cfgs.RADIUS_Server:split() or {}
    local RadiusP_old = cfgs.RADIUS_Port:split() or {}
    local RadiusS_old_i = (RadiusS_old[1] or ''):split(";")
    local RadiusP_old_i = (RadiusP_old[1] or ''):split(";")
    local RadiusS_new = diff.RADIUS_Server and diff.RADIUS_Server[2]:split() or RadiusS_old
    local RadiusP_new = diff.RADIUS_Port and diff.RADIUS_Port[2]:split() or RadiusP_old
    local RadiusS_new_i = (RadiusS_new[1] or ''):split(";") --split by ";"
    local RadiusP_new_i = (RadiusP_new[1] or ''):split(";")

    local auth_old1 = auth_old[1]:split(";") --auth_old1[1]=OPEN,auth_old1[2]=WPA2PSK
    local encr_old1 = encr_old[1]:split(";")
    for i = 1, #encr_old1 do
        local changed = false
        if next(auth_new) and auth_old1[i] ~= auth_new1[i] then
            changed = true
        elseif next(encr_new) and encr_old1[i] ~= encr_new1[i] then
            changed = true
        elseif diff["WPAPSK"..tostring(i)] then
            changed = true
        elseif next(RadiusS_new) and RadiusS_old_i[i] ~= RadiusS_new_i[i] then
            changed = true
        elseif next(RadiusP_new) and RadiusP_old_i[i] ~= RadiusP_new_i[i] then
            changed = true
        elseif diff["RADIUS_Key"..tostring(i)] then
            changed = true
        else
            for j = 1, 4 do
                if diff["Key"..tostring(j).."Str"..tostring(i)] then
                    changed = true
                    break
                end
            end
        end
        if changed then
            local vif = {}
            vif.idx = i
            vif.vifname = device.ext_ifname..tostring(i-1)
            vif.AuthMode = auth_new1 and auth_new1[i] or auth_old1[i]
            vif.EncrypType = encr_new1 and encr_new1[i] or encr_old1[i]
            vif.Key1 = diff["Key1Str"..tostring(i)] and diff["Key1Str"..tostring(i)][2] or cfgs["Key1Str"..tostring(i)]
            vif.WPAPSK = diff["WPAPSK"..tostring(i)] and diff["WPAPSK"..tostring(i)][2] or cfgs["WPAPSK"..tostring(i)]
            vif.SSID = diff["SSID"..tostring(i)] and diff["SSID"..tostring(i)][2] or cfgs["SSID"..tostring(i)]
            vif.RADIUS_Server = RadiusS_new_i and RadiusS_new_i[i] or RadiusS_old_i[i]
            vif.RADIUS_Port = RadiusP_new_i and RadiusP_new_i[i] or RadiusP_old_i[i]
            vif.RADIUS_Key = diff["RADIUS_Key"..tostring(i)] and diff["RADIUS_Key"..tostring(i)][2] or cfgs["RADIUS_Key"..tostring(i)]
            table.insert(vifs, vif)
        end
    end

    -- iwpriv here
    for i, vif in ipairs(vifs) do
        if vif.AuthMode == "OPEN" then
            if vif.EncrypType == "WEP" then
                commands = string.format([[
                iwpriv %s set AuthMode=OPEN;
                iwpriv %s set EncrypType=WEP;
                iwpriv %s set Key1="%s";
                iwpriv %s set DefaultKeyID=1;
                iwpriv %s set IEEE8021X=0;]],
            vif.vifname, vif.vifname, vif.vifname, vif.Key1,
            vif.vifname, vif.vifname)
            else
                commands = string.format([[
                iwpriv %s set AuthMode=OPEN;
                iwpriv %s set EncrypType=NONE;
                iwpriv %s set IEEE8021X=0;]],
            vif.vifname, vif.vifname, vif.vifname)
            end
        elseif vif.AuthMode == "SHARED" then
            commands = string.format([[
                iwpriv %s set AuthMode=SHARED;
                iwpriv %s set EncrypType=WEP;
                iwpriv %s set Key1="%s";
                iwpriv %s set DefaultKeyID=1;
                iwpriv %s set IEEE8021X=0;]],
            vif.vifname, vif.vifname, vif.vifname, vif.Key1,
            vif.vifname, vif.vifname)
        elseif vif.AuthMode == "WPA2PSK" then
            commands = string.format([[
                iwpriv %s set AuthMode=WPA2PSK;
                iwpriv %s set EncrypType=%s;
                iwpriv %s set WPAPSK="%s";]],
            vif.vifname, vif.vifname, vif.EncrypType, vif.vifname, vif.WPAPSK)
        elseif vif.AuthMode == "WPAPSKWPA2PSK" then
            commands = string.format([[
                iwpriv %s set AuthMode=WPAPSKWPA2PSK;
                iwpriv %s set EncrypType=TKIPAES;
                iwpriv %s set WpaMixPairCipher=WPA_TKIP_WPA2_AES;
                iwpriv %s set WPAPSK="%s";]],
            vif.vifname, vif.vifname, vif.vifname, vif.vifname, vif.WPAPSK)
        elseif vif.AuthMode == "WPAPSK" then
            commands = string.format([[
                iwpriv %s set AuthMode=WPAPSK;
                iwpriv %s set EncrypType=%s;
                iwpriv %s set WPAPSK="%s";]],
            vif.vifname, vif.vifname, vif.EncrypType,
            vif.vifname, vif.WPAPSK)
        elseif vif.AuthMode == "WPA" or vif.AuthMode == "WPA2" or vif.AuthMode == "WPA3" then
            commands = string.format([[
                iwpriv %s set AuthMode=%s;
                iwpriv %s set EncrypType=%s;
                iwpriv %s set RADIUS_Server=%s;
                iwpriv %s set RADIUS_Port=%s;
                iwpriv %s set RADIUS_Key=%s;
                iwpriv %s set IEEE8021X=0;]],
            vif.vifname, vif.AuthMode, vif.vifname, vif.EncrypType,vif.vifname, vif.RADIUS_Server,
            vif.vifname,vif.RADIUS_Port, vif.vifname, vif.RADIUS_Key, vif.vifname)
        else
            error(string.format("invalid AuthMode \"%s\"", vif.AuthMode))
        end

        -- must append extra SSID command to make changes take effect
        commands = commands .."\n".. string.format([[
                iwpriv %s set SSID="%s";]], vif.vifname, vif.SSID)
        print(commands)
    end
end


function diff_profile(datold, datnew)
    if not datold or not datnew then
        error("Usage: datdiff <dat-old> <dat-new>")
        return
    end

    local diff = {}
    local cfg1 = load_profile(datold) or {}
    local cfg2 = load_profile(datnew) or {}

    for k,v in pairs(cfg1) do
        if cfg2[k] ~= cfg1[k] then
            diff[k] = {cfg1[k] or "", cfg2[k] or ""}
        end
    end

    for k,v in pairs(cfg2) do
        if cfg2[k] ~= cfg1[k] then
            diff[k] = {cfg1[k] or "", cfg2[k] or ""}
        end
    end

    if not iwpriv_mode then
        for k,v in pairs(diff) do
            print(datold..":"..k.."="..v[1])
            print(datnew..":"..k.."="..v[2])
        end
    end

    return diff
end


-- mapping dat-diff into iwpriv
function diff_profile_iwpriv(datold, datnew)
    if not datold or not datnew then
        error("Usage: datdiff -x <dat-old> <dat-new>")
        return
    end
    local l1dat = load_l1profile(l1profile)
    local cfgs = load_profile(datold)
    local diff = diff_profile(datold, datnew)
    local device = nil

    for i, dev in ipairs(l1dat) do
        if dev.profile_path == datold then
            device = dev
            break
        elseif dev.profile_path == datnew then
            device = dev
            break
        end
    end

    if not device then
        error("cannot find device of "..datnew)
    end
    -- __set_wifi_misc(cfgs, diff, device)

    -- security is complicated enough to get a special API
    __set_wifi_security(cfgs, diff, device)
end


function get_vif_by_ifname(ucicfg, ifname)
    for vifname, vif in pairs(ucicfg["wifi-iface"]) do
        if vifname == ifname then
            return vif
        end
    end
end

function get_vifs_by_dev(ucicfg, devname)
    local vifs = {}
    for vifname, vif in pairs(ucicfg["wifi-iface"]) do
        if vif.device == devname then
            if tonumber(vif.vifidx) then
                vifs[#vifs +1] = vif
            end
        end
    end

    table.sort(vifs, function(a , b)
        return tostring(a.vifidx) < tostring(b.vifidx)
    end)

    for vifname, vif in pairs(ucicfg["wifi-iface"]) do
        if vif.device == devname then
            if tonumber(vif.vifidx) == nil  then
                vifs[#vifs+1] = vif
            end
        end
    end

    return vifs
end

function get_wlan_macaddr(ifname)
    local rsfile = io.popen('getmac '..ifname)
    local macaddr = rsfile:read("*all")
    --print("macaddr: "..macaddr)
    --print(#macaddr)
    --print(string.len(macaddr))
    if (#macaddr >= 17) then
        macaddr = string.sub(macaddr, 1, 17)
        ---- TODO: NEED check mac vaild
        if (macaddr == "ff:ff:ff:ff:ff:ff") or (macaddr == "00:00:00:00:00:00") then
            print("invalid mac so return err")
            return "err"
        else
        --print("return OK")
        return macaddr
        end
    else
        print("invalid mac so return err")
        return "err"
    end
end

function vif_cfg_ssid(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local macaddr = string

    t["BssidNum"] = #vifs
    for i,vif in ipairs(vifs) do
        if vif.mode == "ap" then
            t["SSID"..tostring(i)] = vif.ssid
        elseif vif.mode == "sta" then
            t["ApCliSsid"] = vif.ssid
            t["BssidNum"] = t["BssidNum"] - 1
        end
        vif.ssid = nil
    end
    for i,vif in ipairs(vifs) do
        if vif.mode == "ap" then
            t["IFNAME"..tostring(i)] = vif.ifname
            if i == 1 then
                macaddr = get_wlan_macaddr(vif.ifname)
                if macaddr == "err" then
                else
                    t["MacAddress"] = macaddr
                end
            end
        end
        vif.ifname = nil
    end
    return t
end

function vif_cfg_by_index(vifs, ucikey, datkey)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local key = datkey
    if not key then key = ucikey end

    for i, vif in ipairs(vifs) do
        if ucikey and ucikey:find("list") and vif[ucikey] then
            local list= vif[ucikey]:split(" ") or {}
            local strbuf = ""
            for  k, v in ipairs(list) do
                strbuf = strbuf..tostring(v)
                -- don't forget the delimiter ";"
                if k<#list then strbuf = strbuf..";" end
            end
            vif[ucikey] = strbuf
        end
        t[key..tostring(i-1)] = vif[ucikey]
        vif[ucikey] = nil
    end

    return t
end

function vif_cfg_list(vifs, ucikey, datkey)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local key = datkey
    if not key then key = ucikey end

    for i, vif in ipairs(vifs) do
        if ucikey and vif[ucikey] then
            if type(vif[ucikey]) == "string" and vif[ucikey] == "" then
                break
            end
            local strbuf = ""
            for  k, v in ipairs(vif[ucikey]) do
                strbuf = strbuf..tostring(v)
                -- don't forget the delimiter ";"
                if k<#vif[ucikey] then strbuf = strbuf..";" end
            end
            vif[ucikey] = strbuf
        end
        t[key..tostring(i-1)] = vif[ucikey]
        vif[ucikey] = nil
    end

    return t
end

function vif_cfg_wds(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local ap_wds = ""

    for i, vif in ipairs(vifs) do
        repeat
            if vif.device ~= "MT7915D_1_2" then
                break
            end

            if vif.mode == "ap" then
                if vif.wds and tonumber(vif.wds) == 1 then
                    ap_wds = ap_wds.."1"
                else
                    ap_wds = ap_wds.."0"
                end

                if i < #vifs then
                    ap_wds = ap_wds..";"
                end

                t["ApMWDS"] = ap_wds
                vif.wds = nil
            elseif vif.mode == "sta" then
                t["ApCliMWDS"] = vif.wds or '0'
                vif.wds = nil
            end

        until true

    end

    return t
end

function vif_cfg_ap_bh(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local uci_r = require "uci".cursor()
    local t = {}

    for i,vif in ipairs(vifs) do
        for k, v in pairs(vif) do
            if k == ".name" and v == "bh_5G_ap" then
                local aplimit = uci_r:get("wireless", "bh_5G_ap", "mesh_aplimit")
                local apmac = uci_r:get("wireless", "bh_5G_ap", "mesh_apmac")
                local meshid = uci_r:get("wireless", "bh_5G_ap", "mesh_id")

                if aplimit ~= nil  then
                    t["mesh_aplimit"] = aplimit
                    vif.mesh_aplimit = nil
                end

                if apmac ~= nil then
                    t["mesh_apmac"] = apmac
                    vif.mesh_apmac = nil
                end

                if meshid ~= nil then
                    t["mesh_id"] = meshid
                    vif.mesh_id = nil
                end
            end
        end
    end

    return t
end

function key_to_table(key)
    local t = {}
    if key and key ~="" then
        t = key:split(";")
    end

    return t
end

function dat2uci_vif_cfg_encryption(auth,encr)
    if auth == "OPEN" and encr == "NONE" then
        encr = "none"
    elseif auth == "OPEN" and encr == "WEP" then
        encr = "wep-open"
    elseif auth == "SHARED" and encr == "WEP" then
        encr = "wep-shared"
    elseif auth == "WPAPSK" and encr == "AES" then
        encr = "psk"
    elseif auth == "WPAPSK" and encr == "TKIP" then
        encr = "psk+tkip"
    elseif auth == "WPAPSK" and encr == "TKIPAES" then
        encr = "psk+tkip+ccmp"
    elseif auth == "WPA2PSK" and encr == "AES" then
        encr = "psk2"
    elseif auth == "WPA2PSK" and encr == "TKIP" then
        encr = "psk2+tkip"
    elseif auth == "WPA2PSK" and encr == "TKIPAES" then
        encr = "psk2+tkip+ccmp"
    elseif auth == "WPAPSKWPA2PSK" and encr == "AES" then
        encr = "mixed-psk"
    elseif auth == "WPAPSKWPA2PSK" and encr == "TKIP" then
        encr = "psk-mixed+tkip"
    elseif auth == "WPAPSKWPA2PSK" and encr == "TKIPAES" then
        encr = "psk-mixed+tkip+ccmp"
    elseif auth == "WPA" and encr == "AES" then
        encr = "wpa"
    elseif auth == "WPA2" and encr == "AES" then
        encr = "wpa2"
    elseif auth == "WPA1WPA2" and encr == "AES" then
        encr = "wpa+wpa2"
    elseif auth == "WPA3" and encr == "AES" then
        encr = "ccmp"
    else -- default, open
        encr = "none"
    end
    return encr
end

function vif_cfg_encryption(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    local auth = ""
    local encr = ""
    local apcli_auth = ""
    local apcli_encr = ""
    local auth_server = ""
    local auth_port = ""
    local auth_secret = ""
    local pmfmfpc = ""
    local pmfmfpr = ""
    local pmfsha256 = ""

    for i, vif in ipairs(vifs) do
        if vif.mode == "ap" then
            if vif.encryption == "none" then
                auth = auth.."OPEN"
                encr = encr.."NONE"
            elseif vif.encryption == "mixed-psk" then --wpa+wpa2  PSK
                auth = auth.."WPAPSKWPA2PSK"
                encr = encr.."TKIPAES"
            elseif vif.encryption == "psk2" then    -- WPA2 PSK
                auth = auth.."WPA2PSK"
                encr = encr.."AES"
            elseif vif.encryption == "psk2+ccmp" then   -- WPA2+WAP3 PSK
                auth = auth.."WPA2PSKWPA3PSK"
                encr = encr.."AES"
            elseif vif.encryption == "ccmp" then    -- WPA3 PSK
                auth = auth.."WPA3PSK"
                encr = encr.."AES"
            elseif vif.encryption == "wpapsk-mix" then    -- wpapsk-mix
                auth = auth.."WPAPSK"
                encr = encr.."TKIPAES"
            else -- TODO: just suport PSK (WPA/WPA2 WPA2 WPA2/WPA3 WPA4) and OPEN
                auth = auth.."OPEN"
                encr = encr.."NONE"
            end
            

            if vif.auth_server == nil then
                vif.auth_server='0'
            end
            if vif.auth_port == nil then
                vif.auth_port='0'
            end
            auth_server = auth_server..vif.auth_server
            auth_port = auth_port..vif.auth_port

            if vif.ieee80211w == nil then
                vif.ieee80211w = '0'
            end

            if vif.ieee80211w == "1" then
                pmfmfpc = pmfmfpc..'1'
                pmfmfpr = pmfmfpr..'0'
                pmfsha256 = pmfsha256..'1'
            elseif vif.ieee80211w == "2" then
                pmfmfpc = pmfmfpc..'1'
                pmfmfpr = pmfmfpr..'1'
                pmfsha256 = pmfsha256..'1'
            else
                pmfmfpc = pmfmfpc..'0'
                pmfmfpr = pmfmfpr..'0'
                pmfsha256 = pmfsha256..'0'
            end
            
            -- don't forget the delimiter ";"
            if i<#vifs then
                auth = auth..";"
                encr = encr..";"
                -- for wpa*
                auth_server = auth_server..";"
                auth_port = auth_port..";"

                pmfmfpr = pmfmfpr..";"
                pmfsha256 = pmfsha256..";"
            end

            t["AuthMode"] = auth
            t["EncrypType"] = encr

            t["RADIUS_Server"] = auth_server
            t["RADIUS_Port"] = auth_port
            t["RADIUS_Key"..tostring(i)] = vif.auth_secret or auth_secret

            t["PMFMFPC"] = pmfmfpc
            t["PMFMFPR"] = pmfmfpr
            t["PMFSHA256"] = pmfsha256

            -- WEP keys
            t["Key"..tostring(i).."Type"] = "1" -- 0=hex, 1=string
            if vif.key1 ~= nil and (#vif.key1 == 7 or #vif.key1 == 15) then
                vif.key1 = string.sub(vif.key1,3)
            end
            t["Key1Str"..tostring(i)] = vif.key1
            t["Key2Str"..tostring(i)] = vif.key2
            t["Key3Str"..tostring(i)] = vif.key3
            t["Key4Str"..tostring(i)] = vif.key4
            t["DefaultKeyID"] = 0

            -- PSK keys
            if vif.sae_password ~= nil then
                t["WPAPSK"..tostring(i)] = vif.sae_password
            else
                t["WPAPSK"..tostring(i)] = vif.key
            end

            -- unset keys already done
            vif.key = nil
            vif.key1 = nil
            vif.key2 = nil
            vif.key3 = nil
            vif.key4 = nil
            vif.auth_secret = nil
            vif.encryption = nil
            vif.sae = nil
            vif.sae_password = nil
            vif.ieee80211w = nil

        elseif vif.mode == "sta" then
            if vif.encryption == "none" then
                apcli_auth = "OPEN"
                apcli_encr = "NONE"
            elseif vif.encryption == "mixed-psk" then --wpa+wpa2  PSK
                apcli_auth = "WPAPSKWPA2PSK"
                apcli_encr = "TKIPAES"
            elseif vif.encryption == "psk2" then    -- WPA2 PSK
                apcli_auth = "WPA2PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "psk2+ccmp" then   -- WPA2+WAP3 PSK
                apcli_auth = "WPA2PSKWPA3PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "ccmp" then    -- WPA3 PSK
                apcli_auth = "WPA3PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "wpapsk-mix" then    -- wpapsk-mix
                apcli_auth = "WPAPSK"
                apcli_encr = "TKIPAES"
            elseif vif.encryption == "WPAPSK" then --old uci WPA PSK
                apcli_auth = "WPAPSK"
                apcli_encr = "AES"
            elseif vif.encryption == "WPA2PSK" then --old uci WPA2 PSK
                apcli_auth = "WPA2PSK"
                apcli_encr = "AES"
            elseif vif.encryption == "WPA3PSK" then --old uci WPA3 PSK
                apcli_auth = "WPA3PSK"
                apcli_encr = "AES"
            else -- TODO: just suport PSK (WPA/WPA2 WPA2 WPA2/WPA3 WPA3) and OPEN
                apcli_auth = "OPEN"
                apcli_encr = "NONE"
            end

            t["ApCliEnable"] = 1
            t["ApCliAuthMode"] = apcli_auth
            t["ApCliEncrypType"] = apcli_encr
            t["ApCliWPAPSK"] = vif.key

            -- unset keys already done
            vif.key = nil
            vif.key1 = nil
            vif.key2 = nil
            vif.key3 = nil
            vif.key4 = nil
            vif.auth_secret = nil
            vif.encryption = nil
        end
    end

    return t
end


--[[
    Traslate ucikey into datkey by vifs (per SSID)

    vifs:      wifi interfaces(per SSID)
    ucikey:    the keyword defined in uci config
    datkey:    coresponding keyword in dat, optional.
    default:   default value if key is not specified
]]

function vif_cfg_by_key(vifs, ucikey, datkey, default)
    local t = {}

    local key = datkey
    local strbuf = ""
    if not key then key = ucikey end
    if not default then default = 0 end

    for i,vif in ipairs(vifs) do
        if type(vif[ucikey]) == "string" or type(vif[ucikey]) == "number" then
            strbuf = strbuf..tostring(vif[ucikey])
        else
            strbuf = strbuf..tostring(default)
        end
        -- don't forget the delimiter ";"
        if i<#vifs then strbuf = strbuf..";" end

        -- unset keys already done
        vif[ucikey] = nil
    end

    t[key] = strbuf

    return t
end

function wmm_edca_parm(ucikey)
    local parms = {"Aifsn", "Cwmax", "Cwmin", "Txop"}
    for _, pat in ipairs(parms) do
        if string.find(ucikey, pat) then
            return true
        end
    end
    return false
end

function vif_cfg_ignore(vifs, ucikey)
    if type(ucikey) == "string" then
        for i,vif in ipairs(vifs) do
            vif[ucikey] = nil
        end
    elseif type(ucikey) == "table" then
        for _,key in ipairs(ucikey) do
            for i,vif in ipairs(vifs) do
                vif[key] = nil
            end
        end
    end
end


function vif_cfg_all(vifs)
    if #vifs < 1 then return end
    local t = {}

    local keys = {}
    for _,vif in pairs(vifs) do
        for k,_ in pairs(vif) do
            keys[k] = true
        end
    end

    for k,_ in pairs(keys) do
        local strbuf = ""
        for i=1, #vifs do
            v = vifs[i][k]
            if type(v) == "string" or type(v) == "number" then
                strbuf = strbuf..tostring(v)
            else
                strbuf = strbuf..tostring(0)
            end
            -- don't forget the delimiter ";"
            if i<#vifs then strbuf = strbuf..";" end

            -- unset keys already done
            vifs[i][k] = nil
        end
        t[k] = strbuf
    end

    return t
end

function load_l1profile(path, dump)
    local l1dat = {}
    local fd = io.open(path, "rb")
    if not fd then error("failed to open "..path) return end
    for line in fd:lines() do
        local m,n,i,devname = string.find(line, "INDEX(%d)=([^%s\'\"]+)")
        if i and devname then
            local devidx = 1
            for i,dev in ipairs(l1dat) do
                if dev.chipname == devname then
                    devidx = devidx + 1
                end
            end
            l1dat[tonumber(i)+1] = {}
            l1dat[tonumber(i)+1]["chipname"] = devname
            l1dat[tonumber(i)+1]["devname"] = devname.."."..tostring(devidx)
        end
        local m,n,i,k,v = string.find(line, "INDEX(%d)_([%w-_]+)=([^%s\'\"]*)")
        if i and k then
            -- print(i,k,v)
            l1dat[tonumber(i)+1][k] = v
        end
    end

    -- split dbdc dev into 2 devs
    local idx = 1
    local dbdc = {}
    for i,dev in ipairs(l1dat) do
            if dev.profile_path:find(";") then
                    -- make a dup first
                    dbdc[idx] = {}
                    for k,v in pairs(dev) do
                            if v:find(";") then
                                    local v1v2 = v:split(";")
                                    assert(2 == #v1v2)
                                    l1dat[i][k] = v1v2[1]
                                    dbdc[idx][k] = v1v2[2]
                            else
                                    dbdc[idx][k] = v
                            end
                    end
                    dbdc[idx]["devname"] = l1dat[i].devname..".2"
                    l1dat[i]["devname"] = l1dat[i].devname..".1"
                    idx = idx + 1
            end
    end

    local idx = #l1dat + 1
    for _,dev in ipairs(dbdc) do
            l1dat[idx] = {}
            for k,v in pairs(dev) do
                    l1dat[idx][k] = v
            end
            idx = idx + 1
    end


    if dump then
        for i,dev in ipairs(l1dat) do
            for k,v in pairs(dev) do
                print(string.format("l1dat[%d].%s=%s", i, k, v))
            end
        end
    end

    return l1dat
end

function vif_cfg_maclist(vifs)
    assert(vifs)
    assert(type(vifs) == "table")

    local t = {}
    --local key = datkey
    --if not key then key = ucikey end

    for i, vif in ipairs(vifs) do
        -- mesh_ver3/mesh_ver4 and later version only store backhaul macfilter rules in uci, not put into effect
        for k, v in pairs(vif) do
            if k == ".name" and v == "bh_5G_ap" then
                vif["macfilter"] = nil
                vif["maclist"] = nil
                break
            end
        end

        t["AccessPolicy"..tostring(i-1)] = 0
        t["AccessControlList"..tostring(i-1)] = ""
        if vif["macfilter"] == "deny" then
            t["AccessPolicy"..tostring(i-1)] = 2
        elseif vif["macfilter"] == "allow" then
            t["AccessPolicy"..tostring(i-1)] = 1
        end
        vif["macfilter"] = nil
        --print("@@@AccessPolicy"..tostring(i-1).."="..t["AccessPolicy"..tostring(i-1)])

        if vif["maclist"] then
            --print("@@@ vif[maclist] type:"..type(vif["maclist"]))
            if type(vif["maclist"]) == "string" and vif["maclist"] == "" then
                break
            end
            local strbuf = ""
            for  k, v in ipairs(vif["maclist"]) do
                --print("@@@k="..k.." V="..v)

                strbuf = strbuf..tostring(v)
                --print("@@@strbuf="..strbuf)
                -- don't forget the delimiter ";"
                if k<#vif["maclist"] then strbuf = strbuf..";" end
            end
            --vif[ucikey] = strbuf
            t["AccessControlList"..tostring(i-1)] = strbuf
            --print("@@@"..key..tostring(i-1))
        end
        --print("@@@AccessControlList"..tostring(i-1).."="..t["AccessControlList"..tostring(i-1)])
        --t[key..tostring(i-1)] = vif[ucikey]

        vif["maclist"] = nil
    end

    return t
end

function merge_ssid_and_key(uci, vifs)
    for k,v in pairs(uci) do
        if type(v) == "table" then
            if v.ifname ~= nil then
                for i, vif in ipairs(vifs) do
                    if v.ifname == vif.ifname then
                        if v.sae_password and vif.sae_password then
                            vif.sae_password = v.sae_password
                        end
                        if v.key and vif.key then
                            vif.key = v.key
                        end
                        if v.ssid and vif.ssid then
                            vif.ssid = v.ssid
                        end
                    end
                end
            end
        end
    end
end

local UCI = require("luci.model.uci").cursor()

function uci2dat(ucifile, datfile, devname)
    if not ucifile then error("ucifile not specified!") return end
    if not datfile then error("datfile not specified!") return end
    if not devname then error("devname not specified!") return end
    if devname then devname = devname:gsub("%.", "_") end

    local ucicfg = uci.decode(ucifile)
    if not ucicfg then error("unable to decode "..ucifile) return end

    local wireless_cfg = UCI:get_all("wireless")
    local datcfg
    if devname == "MT7915D_1_1" then
        datcfg = load_profile("/lib/firmware/mt7915.dbdc.b0.dat")
    elseif devname == "MT7915D_1_2" then
        datcfg = load_profile("/lib/firmware/mt7915.dbdc.b1.dat")
    else
        datcfg = load_profile(datfile)
    end

    for _,dev in pairs(ucicfg["wifi-device"]) do while true do
        --------------- interface level ---------------
        if devname ~= dev.device then break end
        local vifs = get_vifs_by_dev(ucicfg, devname)
        if not vifs or #vifs < 1 then break end

        local vifscfg = {}
        local devscfg = {}
        local t = {}

        merge_ssid_and_key(wireless_cfg, vifs)
        -- special apis to deal with complicated keys
        t = vif_cfg_encryption(vifs)
        merge_profile(vifscfg, t)

        t = vif_cfg_ssid(vifs)
        merge_profile(vifscfg, t)

        t = vif_cfg_maclist(vifs)
        merge_profile(vifscfg, t)

        -- process ap and sta wds cfg
        t = vif_cfg_wds(vifs)
        merge_profile(vifscfg, t)

        -- process xiao mesh backhual cfg
        t = vif_cfg_ap_bh(vifs)
        merge_profile(vifscfg, t)

        -- common api to fetch a key
        local vif_cfg_uci2dat = {
                    disabled = "Disabled",
                    wmm = "WmmCapable",
                    hidden = "HideSSID",
                    wifimode = "WirelessMode",
                    IgmpSnEnable ="IgmpSnEnable",
                    ap_isolate = "NoForwarding"
            }

        for ucikey,datkey in pairs(vif_cfg_uci2dat) do
            t = vif_cfg_by_key(vifs, ucikey, datkey)
            merge_profile(vifscfg, t)
        end

        merge_profile(vifscfg, t)
        -- ignore a single key
        t = vif_cfg_ignore(vifs, "device")
        merge_profile(vifscfg, t)

        -- ignore a group of keys
        t = vif_cfg_ignore(vifs, {"mode", "network", "bsd"})
        merge_profile(vifscfg, t)

        t = vif_cfg_ignore(vifs, {"auth_port", "auth_secret", "auth_server"})
        merge_profile(vifscfg, t)

        -- fetch all rest keys
        t = vif_cfg_all(vifs)
        merge_profile(vifscfg, t)

        -- dump all we've got
        -- for k,v in __spairs(vifscfg) do print(k.."="..v) end

        devscfg.MuOfdmaDlEnable = 0
        devscfg.MuOfdmaUlEnable = 0
        devscfg.TWTSupport = 0
        devscfg.MuMimoDlEnable = 0
        devscfg.MuMimoUlEnable = 0
        devscfg.SRSDEnable = 0  -- BSS color
        devscfg.SREnable = 0    -- BSS color
        devscfg.CountryCode = "CN"  -- default CN
        devscfg.CountryRegion = 1
        devscfg.CountryRegionABand = 10
        --------------- device level ---------------
        for k,v in pairs(dev) do
            -- Ignore these config, they don't mean anything in MediaTek profile.
            if string.byte(k) == string.byte(".")
            or string.byte(k) == string.byte("_")
            or k == "profile"
            or k == "type"
            or k == "vendor"
            or k == "mode"
            or k == "path" then
                -- ignored

            -- The following keywords are used by openwrt luci ui:
            -- ref: https://wiki.openwrt.org/doc/uci/wireless
            -- We follow its convention.
            elseif k == "channel" then
                if v == "0" then
                    devscfg.AutoChannelSelect = "3"
                else
                    devscfg.AutoChannelSelect = "0"
                end
                devscfg.Channel = v
                devscfg.DfsEnable = 0
            elseif k == "disabled" then
                devscfg.BandDisabled = v
            elseif k == "country" then
                devscfg.CountryCode = v
            elseif k == "region" then
                devscfg.CountryRegion = v
            elseif k == "aregion" then
                devscfg.CountryRegionABand = v
            elseif k == "txpwr" then
                if v == "max" then
                    devscfg.TxPower = 100
                elseif v == "mid" then
                    devscfg.TxPower = 75
                elseif v == "min" then
                    devscfg.TxPower = 50
                end
            elseif k == "ax" then   -- OFDMA, TWT, BSS color
                if v == "0" then
                    devscfg.MuOfdmaDlEnable = 0
                    devscfg.MuOfdmaUlEnable = 0
                    devscfg.TWTSupport = 0
                    devscfg.SRSDEnable = 0
                    devscfg.SREnable = 0
                    if dev.band == "2G" then
                        devscfg.WirelessMode = 9   --11BGN
                        devscfg.VHT_SGI = 0
                    else
                        devscfg.WirelessMode = 14   --11A/AN/AC
                    end
                else
                    devscfg.MuOfdmaDlEnable = 1
                    devscfg.MuOfdmaUlEnable = 0
                    devscfg.TWTSupport = 0
                    devscfg.SRSDEnable = 1
                    devscfg.SREnable = 1
                    if dev.band == "2G" then
                        devscfg.WirelessMode = 16   --11BGN/AX
                        devscfg.VHT_SGI = 0
                    else
                        devscfg.WirelessMode = 17   --11A/AN/AC/AX
                    end
                end
            elseif k == "txbf" then     -- MU-MIMO
                if v == "3" then
                    devscfg.MuMimoDlEnable = 1
                    devscfg.MuMimoUlEnable = 0
                    devscfg.MUTxRxEnable = 1
                elseif v == "0" then
                    devscfg.MuMimoDlEnable = 0
                    devscfg.MuMimoUlEnable = 0
                    devscfg.MUTxRxEnable = 0
                else
                    devscfg.MuMimoDlEnable = 0
                    devscfg.MuMimoUlEnable = 0
                    devscfg.MUTxRxEnable = 0
                end
            elseif k == "bgprotect" then
                devscfg.BGProtection = v
            elseif k == "pktaggre" then
                devscfg.PktAggregate = v
            elseif k == "bw" then
                devscfg.HT_BSSCoexistence = 0
                if v == "0" then
                    if dev.band == "2G" then
                        devscfg.HT_BW = 1
                        devscfg.VHT_BW = 0
                        devscfg.HT_BSSCoexistence = 1
                    else
                        if dev.channel == "165" then
                            devscfg.HT_BW = 0
                            devscfg.VHT_BW = 0
                        else
                            devscfg.HT_BW = 1
                            devscfg.VHT_BW = 1
                        end
                    end
                elseif v == "20" then
                    devscfg.HT_BW = 0
                    devscfg.VHT_BW = 0
                elseif v == "40" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 0
                elseif v == "80" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 1
                elseif v == "160" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 2
                elseif v == "80+80" then
                    devscfg.HT_BW = 1
                    devscfg.VHT_BW = 3
                end
            elseif wmm_edca_parm(k) then
                devscfg[k] = string.gsub(tostring(v), ":", ";")

            -- Some keywords may need special care.

            -- Now I assume that the reset keywords are MediaTek private,
            -- and they all match the MediaTek's keywords.
            -- So, I simply dump the "k=v" pairs.
            else
                devscfg[k] = v
            end
        end

        --if not (devscfg.HT_BW == 1 and devscfg.VHT_BW == 0) then
        --    devscfg.HT_BSSCoexistence = 0
        --end
        -- for k,v in __spairs(devscfg) do print(k.."="..v) end

        merge_profile(datcfg, vifscfg)
        merge_profile(datcfg, devscfg)
    break end end

    os.execute("mkdir -p /tmp/mtk/wifi/")
    local _,_,datbak = datfile:find("([%w%.]+%.dat)")
    if datbak then
        datbak = datbak..".bak"
        os.execute("cp "..datfile.." /tmp/mtk/wifi/"..datbak)
    end

    save_profile(datcfg, (not testmode) and datfile)
end


function dat2uci(datfile, ucifile, devname, ifpre)
    local datcfg = load_profile(datfile)
    if not datcfg then error("unable to open "..datfile) return end
    if devname then devname = devname:gsub("%.", "_") end

    local token = function(str, n, default)
        if not str then return nil end
        local i = 1
        local list = {}
        for k in string.gmatch(str, "([^;]+)") do
            list[i] = k
            i = i + 1
        end
        return list[tonumber(n)] or default
    end

    ucicfg = {}
    ucicfg["wifi-device"] = {}
    ucicfg["wifi-iface"] = {}


    dev = {}
    -- luci keys
    dev.vendor = "mediatek"
    dev.type = "mediatek"
    dev.device = devname
    dev.mode = "ap"
    dev.network = "lan"
    dev.txpower = datcfg.TxPower
    dev.channel = datcfg.Channel
    dev.disabled = datcfg.BandDisabled

    if datcfg.HT_BW == "1" then
        if datcfg.VHT_BW == "0" then
            dev.band = "2G"
            dev.bw = "40"
        elseif datcfg.VHT_BW == "1" then
            dev.band = "5G"
            dev.bw = "80"
        elseif datcfg.VHT_BW == "2" then
            dev.band = "5G"
            dev.bw = "160"
        elseif datcfg.VHT_BW == "3" then
            dev.band = "5G"
            dev.bw = "80+80"
        end
    else
        dev.band = "2G"
        dev.bw = "20"
    end


    -- mediatek keys
    dev.country = datcfg.CountryCode
    dev.bgprotect = datcfg.BGProtection
    dev.shortslot = datcfg.ShortSlot
    dev.pktaggre = datcfg.PktAggregate
    dev.HT_BSSCoexistence = datcfg.HT_BSSCoexistences
    dev.E2pAccessMode = datcfg.E2pAccessMode
    dev.HT_BADecline = datcfg.HT_BADecline
    dev.HT_DisallowTKIP = datcfg.HT_DisallowTKIP
    dev.HT_RDG = datcfg.HT_RDG
    dev.AntCtrl = datcfg.AntCtrl
    dev.APAifsn = string.gsub(datcfg.APAifsn, ";", ":")
    dev.APCwmax = string.gsub(datcfg.APCwmax, ";", ":")
    dev.APCwmin = string.gsub(datcfg.APCwmin, ";", ":")
    dev.APTxop = string.gsub(datcfg.APTxop, ";", ":")
    dev.BSSAifsn = string.gsub(datcfg.BSSAifsn, ";", ":")
    dev.BSSCwmax = string.gsub(datcfg.BSSCwmax, ";", ":")
    dev.BSSCwmin = string.gsub( datcfg.BSSCwmin, ";", ":")
    dev.BSSTxop = string.gsub( datcfg.BSSTxop, ";", ":")



    if dev.band == "5G" then
        dev.aregion = datcfg.CountryRegionABand
    else
        dev.region = datcfg.CountryRegion
    end

    ucicfg["wifi-device"][devname] = dev

    local encr1 = datcfg.EncrypType:split()
    local auth1 = datcfg.AuthMode:split()
    local encr2 = encr1[1]:split(";")
    local auth2 = auth1[1]:split(";")

    for i=1, tonumber(datcfg.BssidNum) do
        local encr = dat2uci_vif_cfg_encryption(auth2[i],encr2[i])
        if dev.band == "5G" then
            j=i-1
        else
            j=i
        end
        local vht_stbc
        local vht_bw_signal
        local vht_sgi
        local vht_ldpc

        if dev.band == "5G" then
            vht_stbc = token(datcfg.VHT_STBC, i) or "0"
            vht_bw_signal = token(datcfg.VHT_BW_SIGNAL, i) or "0"
            vht_sgi = token(datcfg.VHT_SGI, i) or "0"
            vht_ldpc = token(datcfg.VHT_LDPC, i) or "0"
        end
        if encr == "wep-shared" or encr == "wep-open" then
            ucicfg["wifi-iface"][ifpre..tostring(j)] = {
            ssid = datcfg["SSID"..tostring(i)],
            encryption = encr,
            device = devname,
            vifidx = i,
            ifname = ifpre..tostring(j),
            key1 = datcfg["Key1Str"..tostring(i)],
            hidden = token(datcfg.HideSSID, i),
            disabled = token(datcfg.Disabled, i) or "0",
            IgmpSnEnable = token(datcfg.IgmpSnEnable, i) or "0",
            mode = "ap",
            wmm = token(datcfg.WmmCapable, i),
            MgmtTxPwr = token(datcfg.MgmtTxPwr, i),
            Restart = token(datcfg.Restart, i),
            MbssMaxStaNum = token(datcfg.MbssMaxStaNum, i),
            MaxStaNum = token(datcfg.MaxStaNum, i),
            acpolicy = datcfg["AccessPolicy"..tostring(j)],
            acctrllist = key_to_table(datcfg["AccessControlList"..tostring(j)]),
            HT_OpMode = token(datcfg.HT_OpMode, i) or "0",
            HT_GI = token(datcfg.HT_GI, i) or "0",
            HT_STBC = token(datcfg.HT_STBC, i) or "0",
            HT_AMSDU = token(datcfg.HT_AMSDU, i) or "0",
            HT_AutoBA = token(datcfg.HT_AutoBA, i) or "0",
            wifimode = token(datcfg.WirelessMode, i),
            HT_LDPC = token(datcfg.HT_LDPC, i) or "0",
            VHT_STBC = vht_stbc,
            VHT_BW_SIGNAL = vht_bw_signal,
            VHT_SGI = vht_sgi,
            VHT_LDPC = vht_ldpc,
            }
        elseif encr == "wpa" or encr == "wpa2" or encr == "wpa+wpa2" then
            ucicfg["wifi-iface"][ifpre..tostring(j)] = {
            ssid = datcfg["SSID"..tostring(i)],
            encryption = encr,
            device = devname,
            vifidx = i,
            ifname = ifpre..tostring(j),
            auth_server = token(datcfg.RADIUS_Server, i),
            auth_port = token(datcfg.RADIUS_Port, i),
            auth_secret = datcfg["RADIUS_Key"..tostring(i)],
            hidden = token(datcfg.HideSSID, i),
            disabled = token(datcfg.Disabled, i) or "0",
            IgmpSnEnable = token(datcfg.IgmpSnEnable, i) or "0",
            mode = "ap",
            wmm = token(datcfg.WmmCapable, i),
            MgmtTxPwr = token(datcfg.MgmtTxPwr, i),
            Restart = token(datcfg.Restart, i),
            MbssMaxStaNum = token(datcfg.MbssMaxStaNum, i),
            MaxStaNum = token(datcfg.MaxStaNum, i),
            acpolicy = datcfg["AccessPolicy"..tostring(j)],
            acctrllist = key_to_table(datcfg["AccessControlList"..tostring(j)]),
            HT_OpMode = token(datcfg.HT_OpMode, i) or "0",
            HT_GI = token(datcfg.HT_GI, i) or "0",
            HT_STBC = token(datcfg.HT_STBC, i) or "0",
            HT_AMSDU = token(datcfg.HT_AMSDU, i) or "0",
            HT_AutoBA = token(datcfg.HT_AutoBA, i) or "0",
            wifimode = token(datcfg.WirelessMode, i),
            HT_LDPC = token(datcfg.HT_LDPC, i) or "0",
            VHT_STBC = vht_stbc,
            VHT_BW_SIGNAL = vht_bw_signal,
            VHT_SGI = vht_sgi,
            VHT_LDPC = vht_ldpc,
            }
       else
            ucicfg["wifi-iface"][ifpre..tostring(j)] = {
            ssid = datcfg["SSID"..tostring(i)],
            encryption = encr,
            device = devname,
            vifidx = i,
            ifname = ifpre..tostring(j),
            key = datcfg["WPAPSK"..tostring(i)],
            hidden = token(datcfg.HideSSID, i),
            disabled = token(datcfg.Disabled, i) or "0",
            IgmpSnEnable = token(datcfg.IgmpSnEnable, i) or "0",
            mode = "ap",
            wmm = token(datcfg.WmmCapable, i),
            MgmtTxPwr = token(datcfg.MgmtTxPwr, i),
            Restart = token(datcfg.Restart, i),
            MbssMaxStaNum = token(datcfg.MbssMaxStaNum, i),
            MaxStaNum = token(datcfg.MaxStaNum, i),
            acpolicy = datcfg["AccessPolicy"..tostring(j)],
            acctrllist = key_to_table(datcfg["AccessControlList"..tostring(j)]),
            HT_OpMode = token(datcfg.HT_OpMode, i) or "0",
            HT_GI = token(datcfg.HT_GI, i) or "0",
            HT_STBC = token(datcfg.HT_STBC, i) or "0",
            HT_AMSDU = token(datcfg.HT_AMSDU, i) or "0",
            HT_AutoBA = token(datcfg.HT_AutoBA, i) or "0",
            wifimode = token(datcfg.WirelessMode, i),
            HT_LDPC = token(datcfg.HT_LDPC, i) or "0",
            VHT_STBC = vht_stbc,
            VHT_BW_SIGNAL = vht_bw_signal,
            VHT_SGI = vht_sgi,
            VHT_LDPC = vht_ldpc,
            }
        end
    end

    uci.encode(ucicfg, (not testmode) and ucifile)
end


--[[
    A basic imitation of posix "getopt".
]]
function getopt(argv, fmt)
    local tab = {}
    local i = 1

    while i <= #argv do
        local arg = argv[i]
        local m = arg:match("-(%w+)")
        if m then
            if fmt:find(m..":") then
                tab[m] = argv[i+1]
                i = i + 1
            elseif fmt:find(m) then
                tab[m] = true
            else
                error("invalid option "..m)
            end
        else
            table.insert(tab, arg)
        end
        i = i + 1
    end

    return tab
end



----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------
----------------------------  TIME TO GO ----------------------------

local opts = getopt(arg, "l:u:d:hf:tx")
local datfile = opts["f"]
local devname = opts["d"]
if opts["l"] then l1profile = opts["l"] end
if opts["u"] then ucifile = opts["u"] end
if opts["t"] then testmode = true end
if opts["x"] then iwpriv_mode = true end

-- help message
if opts["h"] then
    print([[

This tool translates between openwrt uci configuration and MediaTek WiFi profile.
It can be used in 4 ways as below:

    uci2dat [options] [datfile]
    dat2uci [options] [datfile]
    datdiff <old-dat> <new-dat>
    l1prof  [-l l1profile]

Options:
    -h   display help message.
    -t   test mode, will not modify target files but dump result to stdout.
    -x   iwpriv mode, "datdiff" will generate "iwpriv" commands according to diff result.
    -l   specify l1profile path if available. ("/etc/wireless/l1profile")
    -u   specify uci configuration path. ("/etc/config/wireless")
    -f   specify wifi profile path. ("/etc/wireless/mt76*/mt76*.dat")
    -d   specify device name. It should match the "device" value in both uci configuration
         and l1profile.

Examples: UCI ==> DAT

    1. if l1profile is present.
    uci2dat -u /etc/config/wireless -l /etc/wireless/l1profile.dat

    2. without l1prfile, you need to specify the device name and its profile path.
    uci2dat -u /etc/config/wireless -d mt7628 -f /etc/wireless/mt7628/mt7628.dat

Examples: DAT ==> UCI

    1. if l1profile is present.
    dat2uci -l /etc/wireless/l1profile.dat -u /etc/config/wireless

    2. without l1prfile, you need to specify device and its profile path.
    dat2uci -d mt7628 -u /etc/config/wireless -f /etc/wireless/mt7628/mt7628.dat

    3. without "-u", the result will be print to stdout.
    dat2uci -l /etc/wireless/l1profile.dat
    dat2uci -d mt7613 -f /etc/wireless/mt7613/mt7613.dat

Examples: Dump DAT difference
    1. for human readable result
    datdiff /etc/wireless/mt7615.1.2G.dat.bak /etc/wireless/mt7615.1.2G.dat

    2. translate into executable "iwpriv" commands
    datdiff -x /etc/wireless/mt7615.1.2G.dat.bak /etc/wireless/mt7615.1.2G.dat

Examples: Dump l1profile content
    1. dump default l1profile "/etc/wireless/l1profile.dat"
    l1prof

    2. specify l1profile path
    l1prof -l /tmp/l1profile.dat

]])
    return
end



if arg[0]:match("uci2dat") then
    if datfile then
        uci2dat(ucifile, datfile, devname)
    else
        -- try l1profile
        local l1dat = load_l1profile(l1profile)
        for i, dev in ipairs(l1dat) do
            uci2dat(ucifile, dev.profile_path, dev.devname)
        end
    end
elseif arg[0]:match("dat2uci") then
    print("=====dat2uci=====")
    --[[
    if datfile then
        dat2uci(datfile, ucifile, devname, "ra")
    else
        -- try l1profile
        local l1dat = load_l1profile(l1profile)
        os.execute("mkdir -p /tmp/mtk/wifi")
        os.execute("cp "..ucifile.." /tmp/mtk/wifi/wireless.uci.bak 2>/dev/null")
        os.execute("echo > "..ucifile)
        for i, dev in ipairs(l1dat) do
           print("dat2uci->dev.profile_path,dev.devname,dev.ext_ifname",dev.profile_path, dev.devname, dev.ext_ifname)
            dat2uci(dev.profile_path, ucifile, dev.devname, dev.ext_ifname)
        end
    end
    ]]--
elseif arg[0]:match("datdiff") then
    if iwpriv_mode then
        diff_profile_iwpriv(opts[1], opts[2])
    else
        diff_profile(opts[1], opts[2])
    end
elseif arg[0]:match("l1prof") then
    load_l1profile(l1profile, true)
else
    print("Illegal alias!", arg[0])
end
