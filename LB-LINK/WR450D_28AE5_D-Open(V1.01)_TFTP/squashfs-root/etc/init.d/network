#!/bin/sh /etc/rc.common

START=20
STOP=90

USE_PROCD=1

init_switch() {
	setup_switch() { return 0; }

	include /lib/network
	setup_switch
}

start_service() {
	init_switch
	local flow_ipaddr=`uci get network.lan.ipaddr | tr -d '\n'`
	local type=`uci get system.board.type`
	local proto=

	touch /tmp/net_rebooting

	procd_open_instance
	procd_set_param command /sbin/netifd
	procd_set_param respawn
	procd_set_param watch network.interface
	[ -e /proc/sys/kernel/core_pattern ] && {
		procd_set_param limits core="unlimited"
		echo '/tmp/%e.%p.%s.%t.core' > /proc/sys/kernel/core_pattern
	}
	procd_close_instance
	
	local curr_mode=`uci get internet.config.mode | tr -d '\n'`
        if [ "$curr_mode" == "routerdhcp" -o "$curr_mode" == "routerstatic" -o "$curr_mode" == "bridgestatic" -o "$curr_mode" == "routerpppoe" ];then
        	flow_m=`lsmod | grep flow_manage | wc -l | tr -d '\n'`              
        	[ "$flow_m" == "1" ] && rmmod flow_manage                           
        	insmod /lib/modules/3.10.108/flow_manage.ko ipaddr="$flow_ipaddr"
        fi
 

	#add domain addr 
	brip=`ifconfig br-lan | grep 'inet addr' | cut -d':' -f2 | cut -d' ' -f1 | wc -c | tr -d '\n'`
	dmn=`nvram get blink domain | tr -d '\n'`                                                     
        if [ "$type" = "bridge" -a $brip -gt 7 ];then
		domain -s 1 -i br-lan -u $dmn
	else
		domain -s 0 -u $dmn
		gwip=`uci get network.lan.ipaddr | tr -d '\n'`
		echo "$gwip $dmn" > /etc/hosts
	fi

	if [ "$type" = "bridge" ];then
                #bridge iptable 
                echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables
                echo 1 > /proc/sys/net/bridge/bridge-nf-call-ip6tables
		killall -9 daemon
                daemon &
        else
                #router iptable
                echo 0 > /proc/sys/net/bridge/bridge-nf-call-iptables
                echo 0 > /proc/sys/net/bridge/bridge-nf-call-ip6tables
		killall -9 daemon
		daemon &
        fi

	#hwnat
	hwnatBoot.sh &

	#the routerdhcp mode run ipv6 
	#if [ "$curr_mode" = "routerdhcp" ];then 
        #       broute_ipv6.sh 1 & 
        #else
        #       broute_ipv6.sh 0 & 
        #fi


        /sbin/enable_ipv6.sh &
        lua /sbin/svctl.lua set_iptv_portmap &
       
}

reload_service() {
	ubus call network reload
	/sbin/wifi reload_legacy
	sleep 3
	init_switch
}

stop() {
	/sbin/wifi down
	procd_kill network ''
}

service_running() {
	ubus -t 30 wait_for network.interface
	/sbin/wifi reload_legacy
	sleep 3
	init_switch
}

validate_atm_bridge_section()
{
	uci_validate_section network "atm-bridge" "${1}" \
		'unit:uinteger:0' \
		'vci:range(32, 65535):35' \
		'vpi:range(0, 255):8' \
		'atmdev:uinteger:0' \
		'encaps:or("llc", "vc"):llc' \
		'payload:or("bridged", "routed"):bridged'
}

validate_route_section()
{
	uci_validate_section network route "${1}" \
		'interface:string' \
		'target:cidr4' \
		'netmask:netmask4' \
		'gateway:ip4addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_route6_section()
{
	uci_validate_section network route6 "${1}" \
		'interface:string' \
		'target:cidr6' \
		'gateway:ip6addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_rule_section()
{
	uci_validate_section network rule "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr4' \
		'dest:cidr4' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_rule6_section()
{
	uci_validate_section network rule6 "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr6' \
		'dest:cidr6' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_switch_section()
{
	uci_validate_section network switch "${1}" \
		'name:string' \
		'enable:bool' \
		'enable_vlan:bool' \
		'reset:bool'
}

validate_switch_vlan()
{
	uci_validate_section network switch_vlan "${1}" \
		'device:string' \
		'vlan:uinteger' \
		'ports:list(ports)'
}

service_triggers()
{
	procd_add_reload_trigger network wireless

	procd_open_validate
	validate_atm_bridge_section
	validate_route_section
	validate_route6_section
	validate_rule_section
	validate_rule6_section
	validate_switch_section
	validate_switch_vlan
	procd_close_validate
}

restart() {
	ifdown -a
	sleep 1
	trap '' TERM
	stop "$@"
	start "$@"
}

shutdown() {
	/sbin/wifi down
	ifdown -a
	sleep 1
}
